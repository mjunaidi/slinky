{"name":"Slinky","tagline":"Compiling static file + proxy server for rich client apps","body":"# Slinky\r\n\r\nIf you write single-page rich client apps, Slinky is here to\r\nmake your life easier. For development, it provides a static file\r\nserver that transparently handles compiled languages like CoffeeScript\r\nand SASS while supporting advanced features like dependency management,\r\nproxying and automatic browser reloads. And once you're ready to\r\ndeploy, Slinky will compile, concatenate, and minify your sources,\r\nleaving you ready to push to production.\r\n\r\n[![Build Status](https://secure.travis-ci.org/mwylde/slinky.png)](http://travis-ci.org/mwylde/slinky)\r\n\r\n#### What can slinky do for you?\r\n\r\n##### Slinky Server\r\n\r\n* Transparently compiles sources for a variety of languages\r\n* Supports the [LiveReload](http://livereload.com) protocol, for\r\n  instant browser updates\r\n* Includes a customizable proxy, so your dev environment can mirror production\r\n* Includes support for HTML5 [pushState](https://developer.mozilla.org/en-US/docs/DOM/Manipulating_the_browser_history) based apps\r\n\r\n##### Slinky Builder\r\n\r\n* Keeps track of the proper include order of your scripts and styles\r\n* Compiles, minifies and concatenates JavaScript and CSS\r\n\r\nSlinky is not a framework, and it does not want to control your source\r\ncode. Its goal is to help you when you want it&mdash;and get out of the way\r\nwhen you don't. It endeavors to be sufficiently flexible to support a\r\nwide variety of development styles.\r\n\r\n## Quick start\r\n\r\n```\r\n$ gem install slinky\r\n$ cd ~/my/awesome/project/src\r\n$ slinky start\r\n[hardcore web development action]\r\n$ slinky build -o ../pub\r\n$ scp -r ../pub/ myserver.com:/var/www/project\r\n````\r\n\r\n## The details\r\n\r\n1. [Transparent compilation](#transparent-compilation)\r\n2. [LiveReload/Guard support](#livereloadguard-support)\r\n3. [Script & style management](#script--style-management)\r\n4. [Specifying order](#specifying-order)\r\n5. [Dependencies](#dependencies)\r\n6. [Configuration](#configuration)\r\n7. [PushState](#pushstate)\r\n8. [Proxies](#proxies)\r\n9. [Ignores](#ignores)\r\n10. [Products](#products)\r\n11. [Path matching](#path-matching)\r\n\r\n### Transparent compilation\r\n\r\nThe Slinky server will transparently compile various front-end languages\r\nfor you, providing a smooth transition from development to production.\r\nWhat does this mean? When Slinky sees a request for a file that doesn't\r\nexist (say, \"/scripts/core.js\") it will look for a file that can be compiled\r\ninto that (\"/scripts/core.coffee\"), compile it, then return the result. This\r\nallows you to write code without concern for which files are \"native\"\r\nand which need compilation.\r\n\r\nCurrently supported languages include:\r\n\r\n* CoffeeScript\r\n* HAML\r\n* SASS/SCSS\r\n* LESS\r\n* JSX (react templates)\r\n* ClojureScript (experimental)\r\n\r\nAdding support for new languages is simple, and pull requests are welcome.\r\n\r\n\r\n### LiveReload/Guard support\r\n\r\nThe typical edit-save-reload cycle of web development can be tedious,\r\nespecially when trying to get your CSS *just* right. What if you could\r\nreduce that to just edit-save? [LiveReload](http://livereload.com/)\r\nallows just that. Slinky includes built-in support for LiveReload\r\nservice. All you need to do is run a browser extension (available\r\n[here](http://go.livereload.com/extensions) for Safari, Chrome and\r\nFirefox) or include a little script (http://go.livereload.com/mobile).\r\nIn addition to reloading your app whenever a source file changes,\r\nLiveReload supports hot reloading of CSS, letting you tweak your\r\nstyles with ease. If don't want the LiveReload server running,\r\ndisabling it is a simple `--no-livereload` away.\r\n\r\n### Script & style management\r\n\r\nSlinky can manage all of your javascript and css files if you want it\r\nto, serving them up individually during development and concatenating\r\nand minifying them for production. To support this, Slinky recognizes\r\n`slinky_scripts` in your HTML/HAML files. For example, when Slinky\r\nsees this:\r\n\r\n```haml\r\n!!!5\r\n%html\r\n  %head\r\n    slinky_scripts\r\n    slinky_styles\r\n  %body\r\n    %h1 Hello, world!\r\n```\r\n\r\nit will compile the HAML to HTML and replace slinky_styles with the\r\nappropriate HTML. You can also disable minification with the\r\n`--dont-minify` option or the `dont_minify: true` configuration\r\noption. `slinky_scripts` and `slinky_styles` are conveniences built on\r\ntop of the [full product system](#products).\r\n\r\n### Specifying order\r\n\r\nOften scripts and styles depend on being included in the page\r\nin a particular order. For this, we need the `slinky_require`\r\ndirective.\r\n\r\nFor example, consider the case of two coffeescript files, A.coffee and\r\nB.coffee. A includes a class definition that B depends upon, so we\r\nwant to make sure that A comes before B in the concatenation order.\r\n\r\nFile A.coffee:\r\n\r\n```coffeescript\r\nclass A\r\n  hello: (thing) -> \"Hello, \" + thing\r\n```\r\n\r\nFile B.coffee:\r\n\r\n```coffeescript\r\nslinky_require(\"A.coffee\")\r\nalert (new A).hello(\"world\")\r\n```\r\nWe can also do this in CSS/SASS/SC SS:\r\n\r\n```sass\r\n/* slinky_require(\"reset.css\")\r\na\r\n  color: red\r\n```\r\n\r\n### Dependencies\r\n\r\nAs HAML and SASS scripts can include external content as part of their\r\nbuild process, you may want certain files to be recompiled whenever\r\nother files change. For example, you may use mustache templates\r\ndefined each in their own file, but have set up your HAML file to\r\ninclude them all into the HTML. Thus when one of the mustache files\r\nchanges, you would like the HAML file to be recompiled so that the\r\ntemplates will also be updated.\r\n\r\nThese relationships are specified as \"dependencies,\" and like requirements\r\nthey are incdicated through a special `slinky_depends(\"file\")` directive in\r\nyour source files. For our template example, the index.haml files might look\r\nlike this:\r\n\r\n```haml\r\nslinky_depends(\"scripts/templates/*.mustache\")\r\n!!!5\r\n\r\n%html\r\n  %head\r\n    %title My App\r\n    slinky_styles\r\n    slinky_scripts\r\n    - Dir.glob(\"./scripts/templates/*.mustache\") do |f|\r\n      - name = File.basename(f).split(\".\")[0..-2].join(\".\")\r\n      %script{:id => name, :type => \"text/x-handlebars-template\"}= File.read(f)\r\n  %body\r\n```\r\n\r\n## Configuration\r\n\r\nSlinky can optionally be configured using a yaml file. By default, it\r\nlooks for a file called `slinky.yaml` in the source directory, but you\r\ncan also supply a file name on the command line using `-c`.\r\n\r\nMost of what can be specified on the command line is also available in\r\nthe configuration file. Here's a fully-decked out config:\r\n\r\n```yaml\r\npushstate:\r\n  \"/app1\": \"/index.html\"\r\n  \"/app2\": \"/index2.html\"\r\nproxy:\r\n  \"/test1\": \"http://127.0.0.1:8000\"\r\n  \"/test2\": \"http://127.0.0.1:7000\"\r\nproduce:\r\n  \"/scripts.js\":\r\n    include:\r\n      - \"*.js\"\r\n    exclude:\r\n      - \"/script/vendor/\"\r\n      - \"/script/jquery.js\"\r\n  \"/styles.css\":\r\n    include:\r\n      - \"*.css\"\r\nport: 5555\r\nsrc_dir: \"src/\"\r\nbuild_dir: \"build/\"\r\nno_proxy: true\r\nno_livereload: true\r\nlivereload_port: 5556\r\ndont_minify: true\r\n```\r\n\r\nMost are self explanatory, but a few of the options merit further\r\nattention:\r\n\r\n### PushState\r\n\r\n[PushState](https://developer.mozilla.org/en-US/docs/DOM/Manipulating_the_browser_history)\r\nis a new Javascript API that gives web apps more control over the\r\nbrowser's history, making possible single-page javascript applications\r\nthat retain the advantages of their multi-page peers without resorting\r\nto hacks like hash urls. The essential idea is this: when a user\r\nnavigates to a conceptually different \"page\" in the app, the URL\r\nshould be updated to reflect that so that behaviors such as\r\ndeep-linking and history navigation work properly.\r\n\r\nFor this to work, however, the server must be able to return the\r\ncontent of your main HTML page for arbitrary paths, as otherwise when\r\na user tries to reload a pushstate-enabled web app they would receive\r\na 404. Slinky supports multiple pushState paths using the pushstate\r\nconfiguration option:\r\n\r\n```yaml\r\npushstate:\r\n  \"/\":     \"/index.html\"\r\n  \"/app1\": \"/app1/index.haml\"\r\n  \"/app2\": \"/app2.haml\"\r\n```\r\n\r\nHere, the key of the hash is a URL prefix, while the value is the file\r\nthat should actually be displayed for non-existent requests that begin\r\nwith the key. In the case of conflicting rules, the more specific one\r\nwins. For this config, instead of returning a 404 for a path like\r\n`/this/file/does/not/exist`, Slinky will send the content of\r\n`/index.html`, leaving your JavaScript free to render the proper view for\r\nthat content. Similarly, a request for `/app1/photo/1/edit`, assuming\r\nsuch file does not exist, will return `/app1/index.haml`.\r\n\r\n### Proxies\r\n\r\nSlinky has a built-in proxy server which lets you test ajax requests\r\nwith your actual backend servers without violating the same-origin\r\npolicy. To set it up, your slinky.yaml file will look something like\r\nthis:\r\n\r\n```yaml\r\nproxy:\r\n  \"/login\": \"http://127.0.0.1:4567/login\"\r\n  \"/search\":\r\n    to: \"http://127.0.0.1:4567/search\"\r\n    lag: 2000\r\n```\r\n\r\nWhat does this mean? We introduce the list of proxy rules using the\r\n`proxy` key. Each rule is a key value pair. The key is a url prefix to\r\nmatch against. The first rule is equivalent to the regular expression\r\n`/\\/login.*/`, and will match paths like `/login/user` and\r\n`/login/path/to/file.html`. The value is either a url to pass the\r\nrequest on to or a hash containing configuration (one of which must be\r\na `to` field). Currently a `lag` field is also supported. This delays\r\nthe request by the specified number of milliseconds in order to\r\nsimulate the latency associated with remote servers.\r\n\r\nAn example: we have some javascript code which makes an AJAX GET\r\nrequest to `/search/widgets?q=foo`. When Slinky gets the request it\r\nwill see that it has a matching proxy rule, rewrites the request\r\nappropriately (changing paths and hosts) and sends it on to the backend\r\nserver (in this case, 127.0.0.1:4567). Once it gets a response it will\r\nwait until 2 seconds has elapsed since slinky itself received the\r\nrequest and finally returns the response back to the browser.\r\n\r\n###  Ignores\r\n\r\n_Ignores are deprecated and will be removed in the next major release.\r\nUse the new product system instead._\r\n\r\nBy default slinky will include every javascript and css file it finds\r\ninto the combined scripts.js and styles.css files. However, it may be\r\nthat for some reason you want to keep some files separate and handle\r\nthem manually. The ignore directive lets you do that, by telling the\r\nsystem to skip over any files or directories listed. For example:\r\n\r\n```yaml\r\nignore:\r\n  - script/vendor\r\n  - css/reset.css\r\n```\r\n\r\nThis will causes everything in the script/vendor directory to be\r\nignored by slinky, as well as the reset.css file.\r\n\r\n### Products\r\n\r\n_New in 0.8: use master to get them now_\r\n\r\nProducts are the outputs of the build system. Most files are just\r\ncopied to the build directory, but you may want some to undergo\r\nfurther processing. For simplicity, Slinky defines two default\r\nproducts which you have seen above: `/scripts.js` and `/styles.css`.\r\nThese are defined like this:\r\n\r\n```yaml\r\nproduce:\r\n  \"/scripts.js\":\r\n    include:\r\n      - \"*.js\"\r\n  \"/styles.css\":\r\n    include:\r\n      - \"*.css\"\r\n```\r\n\r\nProducts are defined by an output path (in this case `/scripts.js` and\r\n`/styles.css`), a set of paths to include, and a set of paths to\r\nexclude (with gitignore-style glob patterns supported; see\r\n[here](#path-matching) for the match rules). In development mode, all\r\nof the files included in a product will be included in your html\r\nseparately. When built in production mode, they will all be minified\r\nand concatenated into a single output file. We can also create our own\r\nproducts:\r\n\r\n```yaml\r\nproduce:\r\n  \"/test/test.js\":\r\n    include:\r\n      - \"*_test.js\"\r\n  \"/main.js\":\r\n    include:\r\n      - \"*.js\"\r\n    exclude:\r\n      - \"vendor/jquery*.js\"\r\n      - \"*_test.js\"\r\n  \"/main.css\":\r\n    include:\r\n      - \"*.css\"\r\n    exclude:\r\n      - \"vendor/boostrap.css\"\r\n```\r\n\r\nThis config will produce three products in the build directory:\r\n`test/test.js`, which will include all files ending in `_test.js`,\r\n`main.js` which includes all .js files except jquery and test files,\r\nand `main.css` which includes all css files except for boostrap.css in\r\nthe vendor directory. Custom products can be included in your HTML\r\nlike this:\r\n\r\n```html\r\n<html>\r\n  <head>\r\n    slinky_product(\"/main.js\")\r\n    slinky_product(\"/main.css\")\r\n  </head>\r\n  ...\r\n```\r\n\r\nThe default product directives (`slinky_scripts` and `slinky_styles`)\r\nare merely sugar for `slinky_product(\"/scripts.js\")` and\r\n`slinky_product(\"/styles.css\")`.\r\n\r\n# Path matching\r\n\r\nSeveral slinky config features involve specifying paths, with support\r\nfor globbing. These are interpreted similarly to .gitignore rules. The full\r\nspecification is:\r\n\r\n1. If the pattern ends with a slash, it will only match directories;\r\n   e.g. `foo/` would match a directory `foo/` but not a file `foo`.\r\n   Other than that, the trailing slash is ignored in path handling.\r\n2. If the pattern does not contain a slash, slinky treats it as a\r\n   relative pathname which can match files in any directory. For\r\n   example, the rule `test.js` will matching `/test.js` and\r\n   `/component/test.js`.\r\n3. If the pattern begins with a slash, it will be treated as an\r\n   absolute path starting at the root of the source directory.\r\n4. If the pattern does not begin with a slash, but does contain one or\r\n   more slashes, it will be treated as a path relative to any\r\n   directory. For example, `test/*.js` will match `/test/main.js`, and\r\n   `/component/test/component.js`, but not `main.js`.\r\n5. A single star `*` in a pattern will match any number of characters within a\r\n   single path component. For example, `/test/*.js` will match\r\n   `/test/main_test.js` but not `/test/component/test.js`.\r\n6. A double star `**` will match any number of characters including\r\n   path separators. For example `/scripts/**/main.js` will match any\r\n   file named `main.js` under the `/scripts` directory, including\r\n   `/scripts/main.js` and `/scripts/component/main.js`.\r\n","google":"UA-78795-10","note":"Don't delete this file! It's used internally to help with page regeneration."}